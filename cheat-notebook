;ЗАМИКАННЯ
Замикання в JavaScript - це механізм, який дозволяє функціям памятати та використовувати змінні,
які були створені поза цими функціями. Це означає,
що функція може мати доступ до зовнішніх змінних, навіть після закінчення своєї роботи.

Простіше кажучи, коли функція створюється, вона "замикає" (запамятовує) оточення,
включаючи змінні, функції та параметри, які їй були доступні у момент створення.
Це дозволяє функції продовжувати використовувати ці змінні,
навіть якщо вони вже не доступні зовні.

Замикання корисне, коли вам потрібно зберегти стан або створити приватні змінні для функції.
Воно дозволяє створювати "контекст" для функцій і зберігати дані, які можуть бути недоступні ззовні.

На практиці, замикання використовується для різних завдань,
таких як створення приватних змінних, імітація класів і модульного програмування.
Воно дозволяє писати більш гнучкий і контрольований код,
де функції мають доступ до необхідних даних навіть після їхнього виклику.

;РЕКУРСІЯ
Рекурсія в JavaScript - це коли функція викликає саму себе в своєму власному тілі.
Це означає, що функція виконується знову і знову,
доки не буде виконано певний умовний вихід з рекурсії.

Коли функція викликає саму себе,
вона створює новий екземпляр себе і продовжує виконуватись всередині цього нового контексту.
Цей процес може тривати досягненням умови виходу,
 коли рекурсивний виклик зупиняється і функції починають повертатись назад по стеку викликів.

Рекурсія дозволяє розвязувати складні завдання,
розбиваючи їх на менші аналогічні підзадачі.
Це особливо корисно для задач,
які мають рекурсивну структуру або де зручніше описати рішення у вигляді самовикликів.

Простий приклад рекурсії - обчислення факторіала числа.
Факторіал числа n (позначається як n!) - це добуток всіх цілих чисел від 1 до n.
У функції для обчислення факторіала можна використати рекурсивний підхід,
де факторіал числа n обчислюється як n помножене на факторіал (n-1).
Цей процес продовжується до досягнення значення 1, коли рекурсивні виклики зупиняються.

Рекурсія потребує правильного визначення умови виходу,
щоб уникнути безкінечного виконання функції. Також потрібно обережно використовувати рекурсію,
оскільки неправильно написана рекурсивна функція може призвести до переповнення стеку викликів
і спричинити помилку "Stack Overflow" (переповнення стеку).
// let i = 0;

// function hello(){
//     i++;

//     console.log("hello");

//     if(i < 4){
//         hello();
//     }

// }

// hello();
рекурсії - коли треба зробити унікальне проходження по своїй ще функції,
 але з іншими даними | максимально рекурсія може бути 10 000

;СТЕК(stack)
Стек (stack) - це структура даних, яка працює за принципом "першим прийшов
- останнім вийшов" (LIFO - Last-In-First-Out). В контексті програмування,
стек є важливим поняттям, особливо коли йдеться про виконання функцій.

Коли викликається функція в JavaScript, її контекст виконання,
включаючи локальні змінні та параметри функції, зберігається в стеку викликів.
Кожен новий виклик функції додається до верхнього кінця стеку,
і виконання програми продовжується з коду, що знаходиться в цій функції.

Коли функція повертає значення або завершує своє виконання,
її контекст виконання видаляється зі стеку, і виконання програми продовжується з місця,
де вона була викликана. Цей процес повернення викликів функцій здійснюється в зворотньому порядку,
оскільки останній виклик функції є першим, який виймається зі стеку.

Стек викликів дозволяє контролювати потік виконання програми
і зберігати поточні стани виконання функцій. Використовуючи стек викликів,
ми можемо відслідковувати послідовність викликів функцій та
керувати поверненням до відповідних місць в коді.
// function words(){
// console.log("Hello 1");
// }

// function tell(){
// words()                ;
// console.log("Hello 3")
// }

// function hello(){
// tell()                  ;
// console.log("Hello 2");
// }

// hello() ;

; Різниця між звичайною ФУНКЦІЄЮ і стрілочною функцією (з назвою) в JavaScript полягає у синтаксисі та поведінці цих функцій.

Синтаксис:

Звичайна функція оголошується за допомогою ключового слова function,
після якого йде імя функції та список параметрів у круглих дужках,
а потім блок коду у фігурних дужках.
Стрілочна функція (з назвою) оголошується за допомогою стрілочної стрілки (=>),
після якої йде імя функції (опціонально) та список параметрів у круглих дужках,
а потім блок коду у фігурних дужках.
Поведінка:

Звичайна функція має своє власне лексичне середовище та свої власні значення this.
Значення this в звичайній функції визначається контекстом виклику.
Стрілочна функція має лексичне середовище, що береться з оточуючого контексту.
Вона не має власного значення this, воно береться з оточуючого контексту.
Використання:

Звичайні функції корисні для створення методів обєктів, конструкторів,
обробників подій та виконання складних дій.
Стрілочні функції зручні для простих та однорядкових функцій,
особливо коли потрібно зберігати значення this зовнішнього контексту.
У великій мірі використання звичайних функцій або стрілочних функцій залежить
від контексту та потреб вашого коду.
Обидва типи функцій мають свої особливості та використовуються в різних ситуаціях.

addEventListener та onclick (onmousedown, onmouseenter, ondblclick) - використовувати звичайні функції | у інших ситуаціях використовувати стрілочні

; bind, call, apply
; Метод call:

Викликає функцію з вказаним значенням this та переданими аргументами.
Приймає аргументи окремо, як послідовні аргументи функції.
Наприклад: func.call(obj, arg1, arg2, ...)
; Метод apply:

Викликає функцію з вказаним значенням this та переданими аргументами.
Приймає аргументи у вигляді масиву або псевдомасиву.
Наприклад: func.apply(obj, [arg1, arg2, ...])
; Метод bind:

Повертає нову функцію, яка буде мати вказане значення this та може мати попередньо передані аргументи.
Не викликає функцію, а лише повертає нову функцію зі збереженими параметрами.
Наприклад: var boundFunc = func.bind(obj, arg1, arg2, ...)
Ці методи корисні, коли потрібно контролювати значення this та передавати аргументи до функції в явний спосіб.
 Вони дозволяють змінити контекст виклику функції і використовувати функцію з обєктом,
  який вам потрібен.

// let info = {
//     age: 25,
//     gender: "female"
// }

// function func_1(firstname, lastname){
//     console.log(this, firstname, lastname);
// }

// // func_1("Dasha", "Shevchenko");
// // func_1.bind(info)("Dasha", "Shevchenko");
// // func_1.call(info, "Dasha", "Shevchenko")
// // func_1.apply(info, ["Dasha", "Shevchenko"])


// let data = {
//     name: "Dasha",
//     func_main: func_1.bind(info)
// }

// data.func_main();

;  КОНТЕКСТ - це дані, які зберігає рекурсія
// const calculate = (x, n) => {

//     if (n == 1){
//         console.log(n)
//         return x;
//     }else{
//         let data = x * calculate(x - 1, n - 1);
//         console.log(n)
//         return data
//     }

// }

// console.log(calculate(5, 3));

// Перший етап: 5 , 3 (контекст) - зупиняється на 208 стрічці... чекає і НЕ перходить на 209 стрічку
// Другий етап: 4 , 2 (контекст) - зупиняється на 208 стрічці... чекає і НЕ перходить на 209 стрічку
// Третій етап: 3 , 1 (контекст) - запускаю стрічку 205, там де у мене console.log, ЗАКІНЧУЄ СВОЮ ФУНКЦІЮ на 206 стрічці
// Четвертий етап: 4 , 2 (контекст) (підіймаюсь у гору) - запускає стрічку 209, там де у мене console.log і ЗАКІНЧУЄ СВОЮ ФУНКЦІЮ
// Четвертий етап: 5 , 3 (контекст) (підіймаюсь у гору) - запускає стрічку 209, там де у мене console.log і ЗАКІНЧУЄ СВОЮ ФУНКЦІЮ




// 5 * 4 * 3

// x = 5 * 4 * 3 * 2 * 1 * 0 * ...
// n = 3 , 3 , 3 , 3 , 3 , 3 , ...

// x = 5 * 4 * 3
// n = 3 , 2 , 1
